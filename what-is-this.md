## Что такое YModules?

Модульная система `YModules` применяется к уже готовым блокам, поэтому пригодится вам на последнем этапе разработки.

Допустим, клиентский JavaScript-код вашего сайта уже написан. Теперь код отдельных компонентов можно разместить по контейнерам, называемым `модулями`.

Модуль подобен фантику от конфеты, на котором написано её название и который по сути является просто обёрткой. Система модулей, в свою очередь, напоминает корзинку с разными сладостями, из которой удобно доставать приглянувшиеся конфеты, определяя нужную по фантику.

## Зачем использовать модули?

Чтобы понять, для чего нужны модули, вспомним, как обычно связывают между собой объекты, реализующие функциональность сайта.

Рассмотрим пример: объявим на странице блок с формой авторизации и напишем для неё клиентский JavaScript-код. В нём опишем поведение формы: пусть после нажатия на кнопку `Submit` авторизационные данные отправляются с помощью Ajax, а не через стандартный `form.submit()`.

Допустим, в проекте уже определён специальный компонент `кнопка`, для которого задано конкретное поведение. Логически поведение может быть следующим:

*По клику совершается некое действие. Действие определяется компонентом, из которого кнопка была вызвана*.

Таким образом, форма авторизации должна суметь найти кнопку, вызвать её и слушать событие клика на ней.

Блоки и компоненты тесно связаны и зависят друг от друга, поэтому важно учитывать, готов ли каждый из них для взаимодействия. Модульная система отслеживает готовность всех компонентов за вас и избавляет от необходимости вручную поддерживать зависимости между сущностями в актуальном виде. Это позволяет избегать конфликтов в работе сайта и делает его структуру более логичной.

Две основные функции модуля:

* объявлять себя;
* объявлять, какие модули необходимы для корректной работы данного.

При оформлении формы, к примеру, в виде ymaps-модуля, в нём можно задекларировать зависимость от кнопки. При этом, код формы будет активирован только тогда, когда всё для этого будет готово. В частности, когда кнопка будет готова слушать событие клика на себе.

## Как использовать модули?

Напишем для примера код модуля. Для начала объявим модуль с помощью метода `define()` и назовём его `A`:

````javascript
modules.define(
    'A'
);
````

Объявим также, что наш модуль зависит от модулей `B` и `C`:

````javascript
modules.define(
    'A',
    ['B', 'C'],
);
````

Опишем код модуля `A` в анонимной функции. Код модулей `B` и `C` придёт в эту функцию вторым параметром. Далее их можно будет использовать внутри нашего `A`:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, {B, C}) {

    }
);
````

С помощью метода `provide(a)` разрешим, в свою очередь, другим модулям использовать наш:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, d) {

        provide(a);
    }
);
````

И, наконец, поместим внутрь обёртки начинку – новый компонент `var a = {}`:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, {B, C}) {
        var a = 'Candies are awesome';

        provide(a);
    }
);
````

Готово. Наш компонент помещён в удобный контейнер и доступен для взаимодействия с другими компонентами, расположенными в их собственных модулях.

Вот другой абстрактный пример – код модуля, отвечающего за форму логина:

````javascript
modules.define(
    'y-form',
    ['y-button'],
    function(provide, d) {
        //помещаем код компонента внутрь модуля:
        var form = getElementById('my-form');
        form.on('submit', onSubmited);

        function onSubmited() {
            if ($(d['y-button']).css('disabled')) {
                return false;
            }
            form.submit();
        }
        //конец кода компонента

        provide(form);
    }
);
````

Здесь, в теле анонимной функции, мы программируем поведение формы в зависимости от того, активна кнопка или нет. Используя метод `define()`, мы определяем сам модуль с анонимной функцией внутри. Используя метод `provide()`, мы заявляем, что данный модуль может быть вызван другими.

Модули независимы и запускаются лишь в случае, если все их зависимости зарезолвлены. Резолвятся они асинхронно, и дерево зависимостей строится в рантайме. Модули можно переопределять и доопределять в любой момент.

Дерево зависимостей модульной системы также можно и удобно использовать в любом файловом сборщике: имя модуля легко мапится на имя файла, в котором этот модуль хранится.

## Дополнительные возможности

### Псевдоним (алиас) для зависимости

Как можно было заметить, имени зависимого модуля соответствует ключ в объекте, передаваемом в функцию модуля. Это не всегда удобно, особенно когда имена модулей очень длинные, либо содержат недопустимые для переменной символы. С целью исправить это, имеется возможность передать после имени модуля его алиас, который и будет ключом в объекте, следующим образом:

````javascript
modules.define(
    'y-form',
    [['y-button', 'button']],
    function(provide, {button}) {
        // ...
    }
);
````

### Обработка циклических зависимостей

На первый взгляд кажется логичным, что если некий модуль `A` зависит от другого модуля `B`, то `B` не может зависеть от `A`, т.е. они не могут зависеть друг от друга, модули резолвятся только "в одну сторону". И очевидный выход здесь - выкинуть ошибку при обнаружении подобной зависимости. Однако, рассмотрим следующий пример:

````javascript
modules.define(
    'A',
    ['B'],
    function(provide, d) {
        provide(class A {
            use() {
                return new d.B();
            }
        });
    }
);
modules.define(
    'B',
    ['A'],
    function(provide, d) {
        provide(class B {
            use() {
                return new d.A();
            }
        });
    }
);
````

Здесь, класс `A` использует внутри себя класс `B`, и наоборот. Классы не требуют друг друга для объявления, однако требуют для использования. Такая зависимость допустима.

Модульная система позволяет делать подобное, с оговоркой на некоторые ограничения языка. В момент резолвинга одного из модулей обнаруживается циклическая зависимость, и вместо свойства, соответствующему циклически зависимому модулю, во втором параметре передается геттер. Если не использовать его до `provide`, модули спокойно зарезолвятся, в противном случае будет выкинута ошибка, т.к. такое использование уже невозможно.

Именно по этой причине желательно использовать зависимости как свойства объекта, и именно там, где они нужны, а не дестрактить объект сразу в начале функции. В противном случае можно словить неожданную ошибку и пойти менять модуль, только потому что от него стал зависеть модуль, от которого он зависит сам.